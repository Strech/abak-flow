{"name":"Abak-flow","tagline":"Abak press github + gitflow flow ^___^","body":"Abak-flow\r\n=========\r\nНет, это не новая идеология ведения проекта, это всего лишь набор утилит которые помогают связать использование [git-flow](https://github.com/nvie/gitflow) и [github flow](http://scottchacon.com/2011/08/31/github-flow.html)\r\n\r\n**Начиная с версии v0.2.1 используется авторизация OAuth2. [Как ей пользоваться](https://github.com/Strech/abak-flow/wiki/How-start-work-with-new-abak-flow)**\r\n\r\n# Концепция\r\nИдеология git-flow использует следующий набор веток:\r\n\r\n* *master* - всегда пригодна для развертывания\r\n* *develop* - основная ветка разработки\r\n* *hotfix* - ветка для изменений которые попадут на продакшен сервер\r\n* *feature* - ветки для крупных задач\r\n\r\nGithub-flow же наоборот ведет основную разработку в ветке master, но при этом master является пригодным для развертывания в любой момент.\r\n\r\nПосле долгих раздумий было принято применить следующий набор правил, для разработки на github:\r\n\r\n1. Вся разработка любой задачи и функционала ведется только в ветках **feature**\r\n2. Разработаный функционал из ветки **feature** оформляется pull request только в ветку **develop**\r\n3. Все исправления ошибок, которые должны попасть на продакшен сервер делаются только в ветках **hotfix**\r\n4. Исправленные ошибки из ветки **hotfix** фофрмляются pull request только в ветку **master**\r\n5. После получения исправлений на текущий момент в репозитории инициируется merge ветки **master** в **develop**\r\n\r\n\r\n# Установка\r\n\r\n    $ gem install abak-flow\r\n    $ git config --global alias.request '!request'\r\n    $ git config --global abak.apiuser YOUR_GITHUB_MAIL@gmail.com\r\n    $ git config --global abak.apitoken 0123456789YOUR_GITHUB_API_TOKEN\r\n    $ git remote add upstream git://github.com/GITHUB_PROJECT_USER/GITHUB_PROJECT_NAME.git\r\n    \r\n### А если я использую прокси, как быть?\r\n    $ git config --global abak.proxy http://my-proxy.com:3129\r\n    \r\nДалее по приоритету идут переменные окружения. Сначала **http_proxy**, затем **HTTP_PROXY**\r\n\r\nТ.е если вы используете переменные окружения, то просто не указывайте прокси в конфиге\r\n\r\n---\r\n\r\n**Заметьте:** В конфиге git, значением *abak.apiuser* должен являться тот email адрес, под которым вы заходите на github\r\n\r\n**Обратите внимание:** В данном контексте под **upstream** подразумевается адрес репозитория в который будут оформляться pull request. А репозиторием **origin** будет являться ваш форк \r\n\r\n# С чего начать?\r\n\r\n    $ git request readycheck\r\n\r\nили\r\n    \r\n    $ git request help\r\n    \r\n**Примечание:** Вообще-то все комманды поддерживают опцию *--help*, но вот именно *git request --help* успевает перехватиться самим git и он конечно неодумевает как ему показать хэлп по внешней комманде\r\n\r\n# Примеры использования\r\n### Самый простой способ начать новую задачу:\r\n\r\n    $ git checkout develop\r\n    $ git request feature 'TASK-001'\r\n    $ touch 'hello.txt' && echo 'Hello world!' > hello.txt\r\n    $ git commit -a -m 'Hello world commit'\r\n    $ git request publish\r\n\r\n**Внимание:** Не нужно называться ветку TASK. Используйте префикс задачь из jira\r\n\r\nТеперь то же самое, только словами:\r\n\r\n* Переключимся в ветку develop\r\n* Abak-flow создаст ветку, пригодную для оформления pull request (правила именования и правила самого реквеста)\r\n* Простое создание нового файла\r\n* Git процедуры добавления своих изменений в репозиторий\r\n* Затем публикация вашей ветки на вашем форке (если таковая уже есть, то просто обновление), затем оформление pull request из этой ветки в соответствующую правилам ветку на upstream (в данном случае это будет ветка develop)\r\n\r\nДля задач, которые должны быть выполнены в виде hotfix принцип тот же:\r\n\r\n    $ git checkout master\r\n    $ git request hotfix 'TASK-001'\r\n    $ …\r\n    $ git request publish\r\n\r\n*На самом деле переключаться на master или develop в самом начале вовсе не обязательно, этот шаг был приведен для пущей ясности*\r\n\r\n### Обновление ветки на удаленном репозитории:\r\n\r\n    $ git checkout feature/TASK-001\r\n    $ git request update\r\n\r\n### Завершение текущей задачи:\r\nВообще, завершать задачу лучше только после того, как ваш pull request был принят. Почему? На самом деле по ряду причин. По умолчанию эта команда удаляет как вашу текущую ветку с задачей в локальном репозитории и в добавок ко всему - на вашем удаленном репозитории (форке)\r\n\r\n    $ git checkout feature/TASK-001\r\n    $ git request done \r\n\r\nЧтобы оставить какую либо ветку в живых возможно напрямую указать, какую копию ветки **удалить**, локальную или же удаленную (на origin)\r\n\r\n    $ git checkout feature/TASK-001\r\n    $ git request done --origin\r\n\r\nИли же так\r\n\r\n    $ git checkout feature/TASK-001\r\n    $ git request done --local\r\n\r\n### Проверка актуальности веток:\r\nРаботает основываясь на SHA кодах веток в репозитории.\r\n\r\nВозможные варианты сообщений:\r\n\r\n1. **Ветка может быть удалена** — означает, что SHA ветки присутствует как в локальном, так и в удаленном репозитории (origin), а так же присутствует в основном репозитории проекта (upstream)\r\n2. **Ветка потенциально может быть удалена** — означает, что SHA ветки присутствует как в удаленном репозитории (origin), так и в основном репозитории проекта (upstream), но отсутвует в локальном. Ее можно удалить, если она действительно вам не нужна\r\n3. **Ветка никак не помечена** — означает, что данная ветка отсутствует в одном из удаленных репозиториев или же имеются различия с локальным репозиторием\r\n\r\n```\r\n$ git request garbage\r\n$ ...\r\n$ 6) keep_it_real_test\r\n$      ↪ отсутствует в upstream репозитории\r\n$      ↪ отсутствует в локальном репозитории\r\n$\r\n$ 7) hotfix/SG-2035 → потенциально можно удалить\r\n$      ↪ отсутствует в локальном репозитории\r\n$\r\n$ 8) keep_it_test → потенциально можно удалить\r\n$      ↪ отсутствует в локальном репозитории\r\n$\r\n$ 9) feature/SG-2089 → можно удалить\r\n$ ...\r\n```\r\n\r\n## Маленькие хитрости\r\nЕсли сразу правильно именовать ветки, т.е ветку с задачей создавать с именем, такого формата TASK-001, то, в описание pull request автоматически вставится ссылка на задачу в jira, а в имя pull request сразу вставится название, состоящее из имени задачи, т.е TASK-001\r\n\r\n## А помощь?\r\nМногие команды имеют какие-то дополнительные опции. Но они нужны только в экзотических случаях. Но при любом раскладе подсказку и тонкий намек всегда можно получить воспользовавших такой командой:\r\n\r\n    $ git request done --help\r\n\r\n# В заключении\r\nДанный репозиторий и изложенные в нем идеи ни в коем случае не претендуют на идеал и совершенство. Это всего лишь узко заточенная комбинация гемов\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}